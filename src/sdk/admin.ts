/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Admin {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Approve an app for installation on a workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.apps.approve} - API method documentation
   */
  async adminAppsApprove(
    req: operations.AdminAppsApproveRequest,
    security: operations.AdminAppsApproveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminAppsApproveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminAppsApproveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.apps.approve";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminAppsApproveSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminAppsApproveResponse =
      new operations.AdminAppsApproveResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List approved apps for an org or workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.apps.approved.list} - API method documentation
   */
  async adminAppsApprovedList(
    req: operations.AdminAppsApprovedListRequest,
    security: operations.AdminAppsApprovedListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminAppsApprovedListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminAppsApprovedListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.apps.approved.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminAppsApprovedListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminAppsApprovedListResponse =
      new operations.AdminAppsApprovedListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List app requests for a team/workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.apps.requests.list} - API method documentation
   */
  async adminAppsRequestsList(
    req: operations.AdminAppsRequestsListRequest,
    security: operations.AdminAppsRequestsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminAppsRequestsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminAppsRequestsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.apps.requests.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminAppsRequestsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminAppsRequestsListResponse =
      new operations.AdminAppsRequestsListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Restrict an app for installation on a workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.apps.restrict} - API method documentation
   */
  async adminAppsRestrict(
    req: operations.AdminAppsRestrictRequest,
    security: operations.AdminAppsRestrictSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminAppsRestrictResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminAppsRestrictRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.apps.restrict";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminAppsRestrictSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminAppsRestrictResponse =
      new operations.AdminAppsRestrictResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List restricted apps for an org or workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.apps.restricted.list} - API method documentation
   */
  async adminAppsRestrictedList(
    req: operations.AdminAppsRestrictedListRequest,
    security: operations.AdminAppsRestrictedListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminAppsRestrictedListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminAppsRestrictedListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.apps.restricted.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminAppsRestrictedListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminAppsRestrictedListResponse =
      new operations.AdminAppsRestrictedListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Archive a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.archive} - API method documentation
   */
  async adminConversationsArchive(
    req: operations.AdminConversationsArchiveRequest,
    security: operations.AdminConversationsArchiveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsArchiveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsArchiveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.archive";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsArchiveSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsArchiveResponse =
      new operations.AdminConversationsArchiveResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsArchiveSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsArchiveErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Convert a public channel to a private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.convertToPrivate} - API method documentation
   */
  async adminConversationsConvertToPrivate(
    req: operations.AdminConversationsConvertToPrivateRequest,
    security: operations.AdminConversationsConvertToPrivateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsConvertToPrivateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsConvertToPrivateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.convertToPrivate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsConvertToPrivateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsConvertToPrivateResponse =
      new operations.AdminConversationsConvertToPrivateResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsConvertToPrivateSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsConvertToPrivateErrorSchema =
            utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Create a public or private channel-based conversation.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.create} - API method documentation
   */
  async adminConversationsCreate(
    req: operations.AdminConversationsCreateRequest,
    security: operations.AdminConversationsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.create";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsCreateResponse =
      new operations.AdminConversationsCreateResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsCreateSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsCreateErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Delete a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.delete} - API method documentation
   */
  async adminConversationsDelete(
    req: operations.AdminConversationsDeleteRequest,
    security: operations.AdminConversationsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.delete";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsDeleteResponse =
      new operations.AdminConversationsDeleteResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsDeleteSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsDeleteErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Disconnect a connected channel from one or more workspaces.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.disconnectShared} - API method documentation
   */
  async adminConversationsDisconnectShared(
    req: operations.AdminConversationsDisconnectSharedRequest,
    security: operations.AdminConversationsDisconnectSharedSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsDisconnectSharedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsDisconnectSharedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.disconnectShared";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsDisconnectSharedSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsDisconnectSharedResponse =
      new operations.AdminConversationsDisconnectSharedResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsRenameSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsDisconnectSharedErrorSchema =
            utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List all disconnected channels—i.e., channels that were once connected to other workspaces and then disconnected—and the corresponding original channel IDs for key revocation with EKM.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.ekm.listOriginalConnectedChannelInfo} - API method documentation
   */
  async adminConversationsEkmListOriginalConnectedChannelInfo(
    req: operations.AdminConversationsEkmListOriginalConnectedChannelInfoRequest,
    security: operations.AdminConversationsEkmListOriginalConnectedChannelInfoSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsEkmListOriginalConnectedChannelInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.AdminConversationsEkmListOriginalConnectedChannelInfoRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/admin.conversations.ekm.listOriginalConnectedChannelInfo";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdminConversationsEkmListOriginalConnectedChannelInfoSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsEkmListOriginalConnectedChannelInfoResponse =
      new operations.AdminConversationsEkmListOriginalConnectedChannelInfoResponse(
        {
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        }
      );
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Get conversation preferences for a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.getConversationPrefs} - API method documentation
   */
  async adminConversationsGetConversationPrefs(
    req: operations.AdminConversationsGetConversationPrefsRequest,
    security: operations.AdminConversationsGetConversationPrefsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsGetConversationPrefsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsGetConversationPrefsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.getConversationPrefs";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsGetConversationPrefsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsGetConversationPrefsResponse =
      new operations.AdminConversationsGetConversationPrefsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsGetConversationPrefsSchema =
            utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsUnarchiveErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.getTeams} - API method documentation
   */
  async adminConversationsGetTeams(
    req: operations.AdminConversationsGetTeamsRequest,
    security: operations.AdminConversationsGetTeamsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsGetTeamsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsGetTeamsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.getTeams";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsGetTeamsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsGetTeamsResponse =
      new operations.AdminConversationsGetTeamsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsGetTeamsSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsGetTeamsErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Invite a user to a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.invite} - API method documentation
   */
  async adminConversationsInvite(
    req: operations.AdminConversationsInviteRequest,
    security: operations.AdminConversationsInviteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsInviteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsInviteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.invite";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsInviteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsInviteResponse =
      new operations.AdminConversationsInviteResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsInviteSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsInviteErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Rename a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.rename} - API method documentation
   */
  async adminConversationsRename(
    req: operations.AdminConversationsRenameRequest,
    security: operations.AdminConversationsRenameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsRenameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsRenameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.rename";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsRenameSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsRenameResponse =
      new operations.AdminConversationsRenameResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsRenameSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsUnarchiveErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Add an allowlist of IDP groups for accessing a channel
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.restrictAccess.addGroup} - API method documentation
   */
  async adminConversationsRestrictAccessAddGroup(
    req: operations.AdminConversationsRestrictAccessAddGroupRequestBody,
    security: operations.AdminConversationsRestrictAccessAddGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsRestrictAccessAddGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsRestrictAccessAddGroupRequestBody(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/admin.conversations.restrictAccess.addGroup";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdminConversationsRestrictAccessAddGroupSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsRestrictAccessAddGroupResponse =
      new operations.AdminConversationsRestrictAccessAddGroupResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List all IDP Groups linked to a channel
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.restrictAccess.listGroups} - API method documentation
   */
  async adminConversationsRestrictAccessListGroups(
    req: operations.AdminConversationsRestrictAccessListGroupsRequest,
    security: operations.AdminConversationsRestrictAccessListGroupsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsRestrictAccessListGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsRestrictAccessListGroupsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/admin.conversations.restrictAccess.listGroups";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdminConversationsRestrictAccessListGroupsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsRestrictAccessListGroupsResponse =
      new operations.AdminConversationsRestrictAccessListGroupsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Remove a linked IDP group linked from a private channel
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.restrictAccess.removeGroup} - API method documentation
   */
  async adminConversationsRestrictAccessRemoveGroup(
    req: operations.AdminConversationsRestrictAccessRemoveGroupRequestBody,
    security: operations.AdminConversationsRestrictAccessRemoveGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsRestrictAccessRemoveGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.AdminConversationsRestrictAccessRemoveGroupRequestBody(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/admin.conversations.restrictAccess.removeGroup";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.AdminConversationsRestrictAccessRemoveGroupSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsRestrictAccessRemoveGroupResponse =
      new operations.AdminConversationsRestrictAccessRemoveGroupResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Search for public or private channels in an Enterprise organization.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.search} - API method documentation
   */
  async adminConversationsSearch(
    req: operations.AdminConversationsSearchRequest,
    security: operations.AdminConversationsSearchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsSearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.search";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsSearchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsSearchResponse =
      new operations.AdminConversationsSearchResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsSearchSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsSearchErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Set the posting permissions for a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.setConversationPrefs} - API method documentation
   */
  async adminConversationsSetConversationPrefs(
    req: operations.AdminConversationsSetConversationPrefsRequest,
    security: operations.AdminConversationsSetConversationPrefsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsSetConversationPrefsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsSetConversationPrefsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.setConversationPrefs";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsSetConversationPrefsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsSetConversationPrefsResponse =
      new operations.AdminConversationsSetConversationPrefsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsSetConversationPrefsSchema =
            utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsSetConversationPrefsErrorSchema =
            utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.setTeams} - API method documentation
   */
  async adminConversationsSetTeams(
    req: operations.AdminConversationsSetTeamsRequest,
    security: operations.AdminConversationsSetTeamsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsSetTeamsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsSetTeamsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.setTeams";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsSetTeamsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsSetTeamsResponse =
      new operations.AdminConversationsSetTeamsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Unarchive a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.unarchive} - API method documentation
   */
  async adminConversationsUnarchive(
    req: operations.AdminConversationsUnarchiveRequest,
    security: operations.AdminConversationsUnarchiveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsUnarchiveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsUnarchiveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.unarchive";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsUnarchiveSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsUnarchiveResponse =
      new operations.AdminConversationsUnarchiveResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsUnarchiveSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsUnarchiveErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Add an emoji.
   *
   * @see {@link https://api.slack.com/methods/admin.emoji.add} - API method documentation
   */
  async adminEmojiAdd(
    req: operations.AdminEmojiAddRequestBody,
    security: operations.AdminEmojiAddSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminEmojiAddResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminEmojiAddRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.emoji.add";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminEmojiAddSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminEmojiAddResponse =
      new operations.AdminEmojiAddResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Add an emoji alias.
   *
   * @see {@link https://api.slack.com/methods/admin.emoji.addAlias} - API method documentation
   */
  async adminEmojiAddAlias(
    req: operations.AdminEmojiAddAliasRequestBody,
    security: operations.AdminEmojiAddAliasSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminEmojiAddAliasResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminEmojiAddAliasRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.emoji.addAlias";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminEmojiAddAliasSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminEmojiAddAliasResponse =
      new operations.AdminEmojiAddAliasResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List emoji for an Enterprise Grid organization.
   *
   * @see {@link https://api.slack.com/methods/admin.emoji.list} - API method documentation
   */
  async adminEmojiList(
    req: operations.AdminEmojiListRequest,
    security: operations.AdminEmojiListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminEmojiListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminEmojiListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.emoji.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminEmojiListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminEmojiListResponse =
      new operations.AdminEmojiListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Remove an emoji across an Enterprise Grid organization
   *
   * @see {@link https://api.slack.com/methods/admin.emoji.remove} - API method documentation
   */
  async adminEmojiRemove(
    req: operations.AdminEmojiRemoveRequestBody,
    security: operations.AdminEmojiRemoveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminEmojiRemoveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminEmojiRemoveRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.emoji.remove";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminEmojiRemoveSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminEmojiRemoveResponse =
      new operations.AdminEmojiRemoveResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Rename an emoji.
   *
   * @see {@link https://api.slack.com/methods/admin.emoji.rename} - API method documentation
   */
  async adminEmojiRename(
    req: operations.AdminEmojiRenameRequestBody,
    security: operations.AdminEmojiRenameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminEmojiRenameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminEmojiRenameRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.emoji.rename";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminEmojiRenameSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminEmojiRenameResponse =
      new operations.AdminEmojiRenameResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Approve a workspace invite request.
   *
   * @see {@link https://api.slack.com/methods/admin.inviteRequests.approve} - API method documentation
   */
  async adminInviteRequestsApprove(
    req: operations.AdminInviteRequestsApproveRequest,
    security: operations.AdminInviteRequestsApproveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminInviteRequestsApproveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminInviteRequestsApproveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.inviteRequests.approve";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminInviteRequestsApproveSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminInviteRequestsApproveResponse =
      new operations.AdminInviteRequestsApproveResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List all approved workspace invite requests.
   *
   * @see {@link https://api.slack.com/methods/admin.inviteRequests.approved.list} - API method documentation
   */
  async adminInviteRequestsApprovedList(
    req: operations.AdminInviteRequestsApprovedListRequest,
    security: operations.AdminInviteRequestsApprovedListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminInviteRequestsApprovedListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminInviteRequestsApprovedListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.inviteRequests.approved.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminInviteRequestsApprovedListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminInviteRequestsApprovedListResponse =
      new operations.AdminInviteRequestsApprovedListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List all denied workspace invite requests.
   *
   * @see {@link https://api.slack.com/methods/admin.inviteRequests.denied.list} - API method documentation
   */
  async adminInviteRequestsDeniedList(
    req: operations.AdminInviteRequestsDeniedListRequest,
    security: operations.AdminInviteRequestsDeniedListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminInviteRequestsDeniedListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminInviteRequestsDeniedListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.inviteRequests.denied.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminInviteRequestsDeniedListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminInviteRequestsDeniedListResponse =
      new operations.AdminInviteRequestsDeniedListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Deny a workspace invite request.
   *
   * @see {@link https://api.slack.com/methods/admin.inviteRequests.deny} - API method documentation
   */
  async adminInviteRequestsDeny(
    req: operations.AdminInviteRequestsDenyRequest,
    security: operations.AdminInviteRequestsDenySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminInviteRequestsDenyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminInviteRequestsDenyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.inviteRequests.deny";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminInviteRequestsDenySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminInviteRequestsDenyResponse =
      new operations.AdminInviteRequestsDenyResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List all pending workspace invite requests.
   *
   * @see {@link https://api.slack.com/methods/admin.inviteRequests.list} - API method documentation
   */
  async adminInviteRequestsList(
    req: operations.AdminInviteRequestsListRequest,
    security: operations.AdminInviteRequestsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminInviteRequestsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminInviteRequestsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.inviteRequests.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminInviteRequestsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminInviteRequestsListResponse =
      new operations.AdminInviteRequestsListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List all of the admins on a given workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.teams.admins.list} - API method documentation
   */
  async adminTeamsAdminsList(
    req: operations.AdminTeamsAdminsListRequest,
    security: operations.AdminTeamsAdminsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminTeamsAdminsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminTeamsAdminsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.teams.admins.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminTeamsAdminsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminTeamsAdminsListResponse =
      new operations.AdminTeamsAdminsListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Create an Enterprise team.
   *
   * @see {@link https://api.slack.com/methods/admin.teams.create} - API method documentation
   */
  async adminTeamsCreate(
    req: operations.AdminTeamsCreateRequest,
    security: operations.AdminTeamsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminTeamsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminTeamsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.teams.create";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminTeamsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminTeamsCreateResponse =
      new operations.AdminTeamsCreateResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List all teams on an Enterprise organization
   *
   * @see {@link https://api.slack.com/methods/admin.teams.list} - API method documentation
   */
  async adminTeamsList(
    req: operations.AdminTeamsListRequest,
    security: operations.AdminTeamsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminTeamsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminTeamsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.teams.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminTeamsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminTeamsListResponse =
      new operations.AdminTeamsListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List all of the owners on a given workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.teams.owners.list} - API method documentation
   */
  async adminTeamsOwnersList(
    req: operations.AdminTeamsOwnersListRequest,
    security: operations.AdminTeamsOwnersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminTeamsOwnersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminTeamsOwnersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.teams.owners.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminTeamsOwnersListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminTeamsOwnersListResponse =
      new operations.AdminTeamsOwnersListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Fetch information about settings in a workspace
   *
   * @see {@link https://api.slack.com/methods/admin.teams.settings.info} - API method documentation
   */
  async adminTeamsSettingsInfo(
    req: operations.AdminTeamsSettingsInfoRequest,
    security: operations.AdminTeamsSettingsInfoSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminTeamsSettingsInfoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminTeamsSettingsInfoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.teams.settings.info";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminTeamsSettingsInfoSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminTeamsSettingsInfoResponse =
      new operations.AdminTeamsSettingsInfoResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Set the default channels of a workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.teams.settings.setDefaultChannels} - API method documentation
   */
  async adminTeamsSettingsSetDefaultChannels(
    req: operations.AdminTeamsSettingsSetDefaultChannelsRequestBody,
    security: operations.AdminTeamsSettingsSetDefaultChannelsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminTeamsSettingsSetDefaultChannelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminTeamsSettingsSetDefaultChannelsRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.teams.settings.setDefaultChannels";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminTeamsSettingsSetDefaultChannelsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminTeamsSettingsSetDefaultChannelsResponse =
      new operations.AdminTeamsSettingsSetDefaultChannelsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Set the description of a given workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.teams.settings.setDescription} - API method documentation
   */
  async adminTeamsSettingsSetDescription(
    req: operations.AdminTeamsSettingsSetDescriptionRequest,
    security: operations.AdminTeamsSettingsSetDescriptionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminTeamsSettingsSetDescriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminTeamsSettingsSetDescriptionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.teams.settings.setDescription";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminTeamsSettingsSetDescriptionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminTeamsSettingsSetDescriptionResponse =
      new operations.AdminTeamsSettingsSetDescriptionResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * An API method that allows admins to set the discoverability of a given workspace
   *
   * @see {@link https://api.slack.com/methods/admin.teams.settings.setDiscoverability} - API method documentation
   */
  async adminTeamsSettingsSetDiscoverability(
    req: operations.AdminTeamsSettingsSetDiscoverabilityRequest,
    security: operations.AdminTeamsSettingsSetDiscoverabilitySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminTeamsSettingsSetDiscoverabilityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminTeamsSettingsSetDiscoverabilityRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.teams.settings.setDiscoverability";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminTeamsSettingsSetDiscoverabilitySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminTeamsSettingsSetDiscoverabilityResponse =
      new operations.AdminTeamsSettingsSetDiscoverabilityResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Sets the icon of a workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.teams.settings.setIcon} - API method documentation
   */
  async adminTeamsSettingsSetIcon(
    req: operations.AdminTeamsSettingsSetIconRequestBody,
    security: operations.AdminTeamsSettingsSetIconSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminTeamsSettingsSetIconResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminTeamsSettingsSetIconRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.teams.settings.setIcon";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminTeamsSettingsSetIconSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminTeamsSettingsSetIconResponse =
      new operations.AdminTeamsSettingsSetIconResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Set the name of a given workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.teams.settings.setName} - API method documentation
   */
  async adminTeamsSettingsSetName(
    req: operations.AdminTeamsSettingsSetNameRequest,
    security: operations.AdminTeamsSettingsSetNameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminTeamsSettingsSetNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminTeamsSettingsSetNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.teams.settings.setName";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminTeamsSettingsSetNameSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminTeamsSettingsSetNameResponse =
      new operations.AdminTeamsSettingsSetNameResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Add one or more default channels to an IDP group.
   *
   * @see {@link https://api.slack.com/methods/admin.usergroups.addChannels} - API method documentation
   */
  async adminUsergroupsAddChannels(
    req: operations.AdminUsergroupsAddChannelsRequest,
    security: operations.AdminUsergroupsAddChannelsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsergroupsAddChannelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsergroupsAddChannelsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.usergroups.addChannels";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsergroupsAddChannelsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsergroupsAddChannelsResponse =
      new operations.AdminUsergroupsAddChannelsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Associate one or more default workspaces with an organization-wide IDP group.
   *
   * @see {@link https://api.slack.com/methods/admin.usergroups.addTeams} - API method documentation
   */
  async adminUsergroupsAddTeams(
    req: operations.AdminUsergroupsAddTeamsRequest,
    security: operations.AdminUsergroupsAddTeamsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsergroupsAddTeamsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsergroupsAddTeamsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.usergroups.addTeams";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsergroupsAddTeamsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsergroupsAddTeamsResponse =
      new operations.AdminUsergroupsAddTeamsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List the channels linked to an org-level IDP group (user group).
   *
   * @see {@link https://api.slack.com/methods/admin.usergroups.listChannels} - API method documentation
   */
  async adminUsergroupsListChannels(
    req: operations.AdminUsergroupsListChannelsRequest,
    security: operations.AdminUsergroupsListChannelsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsergroupsListChannelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsergroupsListChannelsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.usergroups.listChannels";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsergroupsListChannelsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsergroupsListChannelsResponse =
      new operations.AdminUsergroupsListChannelsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Remove one or more default channels from an org-level IDP group (user group).
   *
   * @see {@link https://api.slack.com/methods/admin.usergroups.removeChannels} - API method documentation
   */
  async adminUsergroupsRemoveChannels(
    req: operations.AdminUsergroupsRemoveChannelsRequest,
    security: operations.AdminUsergroupsRemoveChannelsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsergroupsRemoveChannelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsergroupsRemoveChannelsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.usergroups.removeChannels";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsergroupsRemoveChannelsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsergroupsRemoveChannelsResponse =
      new operations.AdminUsergroupsRemoveChannelsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Add an Enterprise user to a workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.users.assign} - API method documentation
   */
  async adminUsersAssign(
    req: operations.AdminUsersAssignRequest,
    security: operations.AdminUsersAssignSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsersAssignResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsersAssignRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.users.assign";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsersAssignSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsersAssignResponse =
      new operations.AdminUsersAssignResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Invite a user to a workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.users.invite} - API method documentation
   */
  async adminUsersInvite(
    req: operations.AdminUsersInviteRequest,
    security: operations.AdminUsersInviteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsersInviteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsersInviteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.users.invite";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsersInviteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsersInviteResponse =
      new operations.AdminUsersInviteResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * List users on a workspace
   *
   * @see {@link https://api.slack.com/methods/admin.users.list} - API method documentation
   */
  async adminUsersList(
    req: operations.AdminUsersListRequest,
    security: operations.AdminUsersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.users.list";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsersListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsersListResponse =
      new operations.AdminUsersListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Remove a user from a workspace.
   *
   * @see {@link https://api.slack.com/methods/admin.users.remove} - API method documentation
   */
  async adminUsersRemove(
    req: operations.AdminUsersRemoveRequest,
    security: operations.AdminUsersRemoveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsersRemoveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsersRemoveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.users.remove";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsersRemoveSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsersRemoveResponse =
      new operations.AdminUsersRemoveResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Invalidate a single session for a user by session_id
   *
   * @see {@link https://api.slack.com/methods/admin.users.session.invalidate} - API method documentation
   */
  async adminUsersSessionInvalidate(
    req: operations.AdminUsersSessionInvalidateRequest,
    security: operations.AdminUsersSessionInvalidateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsersSessionInvalidateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsersSessionInvalidateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.users.session.invalidate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsersSessionInvalidateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsersSessionInvalidateResponse =
      new operations.AdminUsersSessionInvalidateResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Wipes all valid sessions on all devices for a given user
   *
   * @see {@link https://api.slack.com/methods/admin.users.session.reset} - API method documentation
   */
  async adminUsersSessionReset(
    req: operations.AdminUsersSessionResetRequest,
    security: operations.AdminUsersSessionResetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsersSessionResetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsersSessionResetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.users.session.reset";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsersSessionResetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsersSessionResetResponse =
      new operations.AdminUsersSessionResetResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Set an existing guest, regular user, or owner to be an admin user.
   *
   * @see {@link https://api.slack.com/methods/admin.users.setAdmin} - API method documentation
   */
  async adminUsersSetAdmin(
    req: operations.AdminUsersSetAdminRequest,
    security: operations.AdminUsersSetAdminSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsersSetAdminResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsersSetAdminRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.users.setAdmin";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsersSetAdminSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsersSetAdminResponse =
      new operations.AdminUsersSetAdminResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Set an expiration for a guest user
   *
   * @see {@link https://api.slack.com/methods/admin.users.setExpiration} - API method documentation
   */
  async adminUsersSetExpiration(
    req: operations.AdminUsersSetExpirationRequest,
    security: operations.AdminUsersSetExpirationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsersSetExpirationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsersSetExpirationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.users.setExpiration";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsersSetExpirationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsersSetExpirationResponse =
      new operations.AdminUsersSetExpirationResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Set an existing guest, regular user, or admin user to be a workspace owner.
   *
   * @see {@link https://api.slack.com/methods/admin.users.setOwner} - API method documentation
   */
  async adminUsersSetOwner(
    req: operations.AdminUsersSetOwnerRequest,
    security: operations.AdminUsersSetOwnerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsersSetOwnerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsersSetOwnerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.users.setOwner";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsersSetOwnerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsersSetOwnerResponse =
      new operations.AdminUsersSetOwnerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Set an existing guest user, admin user, or owner to be a regular user.
   *
   * @see {@link https://api.slack.com/methods/admin.users.setRegular} - API method documentation
   */
  async adminUsersSetRegular(
    req: operations.AdminUsersSetRegularRequest,
    security: operations.AdminUsersSetRegularSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminUsersSetRegularResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminUsersSetRegularRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/admin.users.setRegular";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminUsersSetRegularSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminUsersSetRegularResponse =
      new operations.AdminUsersSetRegularResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }
}
