/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class AdminConversations {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Archive a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.archive} - API method documentation
   */
  async adminConversationsArchive(
    req: operations.AdminConversationsArchiveRequest,
    security: operations.AdminConversationsArchiveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsArchiveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsArchiveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.archive";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsArchiveSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsArchiveResponse =
      new operations.AdminConversationsArchiveResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsArchiveSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsArchiveErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Convert a public channel to a private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.convertToPrivate} - API method documentation
   */
  async adminConversationsConvertToPrivate(
    req: operations.AdminConversationsConvertToPrivateRequest,
    security: operations.AdminConversationsConvertToPrivateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsConvertToPrivateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsConvertToPrivateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.convertToPrivate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsConvertToPrivateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsConvertToPrivateResponse =
      new operations.AdminConversationsConvertToPrivateResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsConvertToPrivateSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsConvertToPrivateErrorSchema =
            utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Create a public or private channel-based conversation.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.create} - API method documentation
   */
  async adminConversationsCreate(
    req: operations.AdminConversationsCreateRequest,
    security: operations.AdminConversationsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.create";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsCreateResponse =
      new operations.AdminConversationsCreateResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsCreateSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsCreateErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Delete a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.delete} - API method documentation
   */
  async adminConversationsDelete(
    req: operations.AdminConversationsDeleteRequest,
    security: operations.AdminConversationsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.delete";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsDeleteResponse =
      new operations.AdminConversationsDeleteResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsDeleteSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsDeleteErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Disconnect a connected channel from one or more workspaces.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.disconnectShared} - API method documentation
   */
  async adminConversationsDisconnectShared(
    req: operations.AdminConversationsDisconnectSharedRequest,
    security: operations.AdminConversationsDisconnectSharedSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsDisconnectSharedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsDisconnectSharedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.disconnectShared";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsDisconnectSharedSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsDisconnectSharedResponse =
      new operations.AdminConversationsDisconnectSharedResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsRenameSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsDisconnectSharedErrorSchema =
            utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Get conversation preferences for a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.getConversationPrefs} - API method documentation
   */
  async adminConversationsGetConversationPrefs(
    req: operations.AdminConversationsGetConversationPrefsRequest,
    security: operations.AdminConversationsGetConversationPrefsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsGetConversationPrefsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsGetConversationPrefsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.getConversationPrefs";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsGetConversationPrefsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsGetConversationPrefsResponse =
      new operations.AdminConversationsGetConversationPrefsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsGetConversationPrefsSchema =
            utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsUnarchiveErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.getTeams} - API method documentation
   */
  async adminConversationsGetTeams(
    req: operations.AdminConversationsGetTeamsRequest,
    security: operations.AdminConversationsGetTeamsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsGetTeamsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsGetTeamsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.getTeams";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsGetTeamsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsGetTeamsResponse =
      new operations.AdminConversationsGetTeamsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsGetTeamsSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsGetTeamsErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Invite a user to a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.invite} - API method documentation
   */
  async adminConversationsInvite(
    req: operations.AdminConversationsInviteRequest,
    security: operations.AdminConversationsInviteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsInviteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsInviteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.invite";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsInviteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsInviteResponse =
      new operations.AdminConversationsInviteResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsInviteSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsInviteErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Rename a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.rename} - API method documentation
   */
  async adminConversationsRename(
    req: operations.AdminConversationsRenameRequest,
    security: operations.AdminConversationsRenameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsRenameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsRenameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.rename";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsRenameSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsRenameResponse =
      new operations.AdminConversationsRenameResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsRenameSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsUnarchiveErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Search for public or private channels in an Enterprise organization.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.search} - API method documentation
   */
  async adminConversationsSearch(
    req: operations.AdminConversationsSearchRequest,
    security: operations.AdminConversationsSearchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsSearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.search";

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsSearchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsSearchResponse =
      new operations.AdminConversationsSearchResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsSearchSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsSearchErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Set the posting permissions for a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.setConversationPrefs} - API method documentation
   */
  async adminConversationsSetConversationPrefs(
    req: operations.AdminConversationsSetConversationPrefsRequest,
    security: operations.AdminConversationsSetConversationPrefsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsSetConversationPrefsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsSetConversationPrefsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.setConversationPrefs";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsSetConversationPrefsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsSetConversationPrefsResponse =
      new operations.AdminConversationsSetConversationPrefsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsSetConversationPrefsSchema =
            utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsSetConversationPrefsErrorSchema =
            utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.setTeams} - API method documentation
   */
  async adminConversationsSetTeams(
    req: operations.AdminConversationsSetTeamsRequest,
    security: operations.AdminConversationsSetTeamsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsSetTeamsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsSetTeamsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.setTeams";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsSetTeamsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsSetTeamsResponse =
      new operations.AdminConversationsSetTeamsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultSuccessTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.defaultErrorTemplate = utils.objectToClass(httpRes?.data);
        }
        break;
    }

    return res;
  }

  /**
   * Unarchive a public or private channel.
   *
   * @see {@link https://api.slack.com/methods/admin.conversations.unarchive} - API method documentation
   */
  async adminConversationsUnarchive(
    req: operations.AdminConversationsUnarchiveRequest,
    security: operations.AdminConversationsUnarchiveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AdminConversationsUnarchiveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AdminConversationsUnarchiveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/admin.conversations.unarchive";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AdminConversationsUnarchiveSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.AdminConversationsUnarchiveResponse =
      new operations.AdminConversationsUnarchiveResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsUnarchiveSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
      default:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.adminConversationsUnarchiveErrorSchema = utils.objectToClass(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }
}
